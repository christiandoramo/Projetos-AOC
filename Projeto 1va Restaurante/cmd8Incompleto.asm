.data
	item_1: .ascii "01" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_2: .ascii "02" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_3: .ascii "03" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_4: .ascii "04" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_5: .ascii "05" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_6: .ascii "06" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_7: .ascii "07" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_8: .ascii "08" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_9: .ascii "09" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_10: .ascii "10" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_11: .ascii "11" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_12: .ascii "12" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_13: .ascii "13" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_14: .ascii "14" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_15: .ascii "15" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_16: .ascii "16" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_17: .ascii "17" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_18: .ascii "18" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_19: .ascii "19" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	item_20: .ascii "20" # codigo
		.space 30 # 5 para o preco e 25 para descricao
	mesa_1: .space 1
    	.ascii "01"
    	.space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_1_relatorio: .space 32
    mesa_2: .space 1
    .ascii "02"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_2_relatorio: .space 32
    mesa_3: .space 1
    .ascii "03"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_3_relatorio: .space 32
    mesa_4: .space 1
    .ascii "04"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_4_relatorio: .space 32
    mesa_5: .space 1
    .ascii "05"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_5_relatorio: .space 32
    mesa_6: .space 1
    .ascii "06"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente,
    mesa_6_relatorio: .space 32
    mesa_7: .space 1
    .ascii "07"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_7_relatorio: .space 32
    mesa_8:.space 1
    .ascii "08"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_8_relatorio: .space 32
    mesa_9: .space 1
    .ascii "09"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_9_relatorio: .space 32
    mesa_10:.space 1
    .ascii "10"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_10_relatorio: .space 32
    mesa_11:.space 1
    .ascii "11"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_11_relatorio:.space 32
    mesa_12:.space 1
    .ascii "12"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_12_relatorio: .space 32
    mesa_13: .space 1
    .ascii "13"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_13_relatorio: .space 32
    mesa_14:.space 1
    .ascii "14"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 4(ITEM-MESA)*20 itens, 6 saldo total, 6 saldo pago
    mesa_14_relatorio: .space 32
    mesa_15:.space 1
    .ascii "15"                                                                                                             # codigo
    .space 29                                                                                                               # 1 status, 2 codigo, 11 telefone,  18 cliente, 20 itens, 6 saldo total, 6 saldo pago
    mesa_15_relatorio: .space 32
	
	
	cmd: .space 53
	cmd1: .asciiz "cardapio_ad"
	cmd2: .asciiz "cardapio_rm"
	cmd3: .asciiz "cardapio_list"
	cmd4: .asciiz "cardapio_format"
	cmd5: .asciiz "mesa_iniciar"
	cmd6: .asciiz "mesa_ad_item"
	cmd7: .asciiz "mesa_rm_item"
	cmd8: .asciiz "mesa_format"
	cmd9: .asciiz "mesa_parcial"
	cmd10: .asciiz "mesa_pagar"
	cmd11: .asciiz "mesa_fechar"
	cmd12: .asciiz "salvar"
	cmd13: .asciiz "recarregar"
	cmd14: .asciiz "formatar"
	cmd_invalido: .asciiz "Comando invalido"
	str_break_line: .asciiz "\n"
	item_adicionado: .asciiz "Item adicionado com sucesso"
	item_ja_cadastrado: .asciiz "Falha: número de item já cadastrado"
	item_invalido: .asciiz "Falha: codigo de item invalido"
	mesa_iniciada: .asciiz "Atendimento iniciado com sucesso\n"
        mesa_ocupada: .asciiz "Falha: mesa ocupada\n"
	mesa_inexistente: .asciiz "Falha: mesa inexistente\n"
	mesa_desocupada: .asciiz "Falha: mesa nao iniciou atendimento"
	mesa_limitada: .asciiz "Falha: mesa atingiu limite de pedidos"
	pedido_adicionado: .asciiz "Pedido adicionado com sucesso"
	item_nao_cadastrado: .asciiz "Falha: item não cadastrado no cardápio"
	nome_restaurante: .asciiz "FIFO-shell>> "
	item_removido: .asciiz "Item removido com sucesso"
	item_nao_consta: .asciiz "Falha: item nao consta na conta"
	
	
.macro fim_de_codigo
	addi $v0, $0, 10
	syscall
.end_macro

.macro entrada_string(%label, %num)
	#Recebe a entrada da string
	addi $v0, $0, 8 #serviço read_string
	la $a0,%label #Pega a entrada e salva em string
	la $a1, %num #vai ler 25 bytes
	syscall #executa o system call de acordo com o número de v0
.end_macro

.macro imprime_texto(%label)
	addi $v0, $0, 4 #serviço print_string
	la $a0, %label #Passa a string de .data como argumento
	syscall #executa o system call de acordo com o número de v0
.end_macro

.macro break_line
	la $a0, str_break_line
	addi $v0, $0, 4
	syscall
.end_macro

.macro compara_cmd(%inicio, %address, %inicio2, %num)
	la $a0, cmd #string1
	addi $a0, $a0, %inicio #possibilita iniciar a string de um ponto sem ser o começo
	
	add $a1, $0, %address #string2
	addi $a1, $a1, %inicio2 #possibilita iniciar a string de um ponto sem ser o começo
	
	addi $a3, $0, %num #numero de caracteres a ser comparado
	jal strcmp
.end_macro

.macro cmd_com_cmd(%cmd, %num, %label)
	la $t0, %cmd # coloca o comando que quer comparar no t0
	compara_cmd(0, $t0, 0, %num) #compara o comando de entrada com o comando da lista
	beq $v0,$0, %label #se eh um comando da lista, desvia
.end_macro

.text
  main:
  	imprime_texto(nome_restaurante)
	entrada_string(cmd, 53) #codigo
	
	#compara os primeiros caracteres e desvia se for igual ao de cardapio
	cmd_com_cmd(cmd1, 1, cardapio) 
	
	#compara os primeiros caracteres e desvia se for igual ao de mesa
	cmd_com_cmd(cmd5, 1, mesa) 
	
	#Se nao eh um comando de cardapio e nem de mesa, entao eh um de arquivo ou invalido
	
	#compara os caracteres e desvia se for igual ao de salvar
	cmd_com_cmd(cmd12, 1, salvar) 
	
	#compara os caracteres e desvia se for igual ao de recarregar
	cmd_com_cmd(cmd13, 1, recarregar) 
	
	#compara os caracteres e desvia se for igual ao de formatar
	cmd_com_cmd(cmd14, 1, formatar) 
	
	imprime_texto(cmd_invalido)
	break_line
	
   	j main #para não acabar o programa
	
  cardapio:
	#compara os caracteres e desvia se for igual ao de cardapio_ad
	cmd_com_cmd(cmd1, 11, cardapio_ad) 
	
	#compara os caracteres e desvia se for igual ao de cardapio_rm
	cmd_com_cmd(cmd2, 11, cardapio_rm) 
	
	#compara os caracteres e desvia se for igual ao de cardapio_list
	cmd_com_cmd(cmd3, 13, cardapio_list)
	
	#compara os caracteres e desvia se for igual ao de cardapio_format
	cmd_com_cmd(cmd4, 15, cardapio_format) 
	
	imprime_texto(cmd_invalido)
	break_line
	j main #voltar a main
	
  cardapio_ad:
  	jal compara_cardapio
  	j main #voltar a main
  cardapio_rm:
  	j main #voltar a main
  cardapio_list:
  	j main #voltar a main
  cardapio_format:
  	j main #voltar a main
  	
  mesa:	
  	#compara os caracteres e desvia se for igual ao de mesa_iniciar
	cmd_com_cmd(cmd5, 12, mesa_iniciar) 
	
	#compara os caracteres e desvia se for igual ao de 
	cmd_com_cmd(cmd6, 12, mesa_ad_item) 
	
  	#compara os caracteres e desvia se for igual ao de
	cmd_com_cmd(cmd7, 12, mesa_rm_item) 
	
	#compara os caracteres e desvia se for igual ao de
	cmd_com_cmd(cmd8, 11, mesa_format) 
	
	#compara os caracteres e desvia se for igual ao de 
	cmd_com_cmd(cmd9, 12, mesa_parcial)
	
	#compara os caracteres e desvia se for igual ao de
	cmd_com_cmd(cmd10, 10, mesa_pagar)
	
	#compara os caracteres e desvia se for igual ao de 
	cmd_com_cmd(cmd11, 11, mesa_fechar) 
	
	imprime_texto(cmd_invalido)
	break_line

  	j main #voltar a main
  	
  	mesa_iniciar:
  	jal verifica_mesa
  	j main #voltar a main
	mesa_ad_item:
	jal mesa_ad_item_ad_item
	
	j main #voltar a main
	mesa_rm_item:
	jal mesa_rm_item_rm_item
	
	j main #voltar a main
	mesa_format:
	j main #voltar a main
	mesa_parcial:
	j main #voltar a main
	mesa_pagar:
	j main #voltar a main
	mesa_fechar:
	j main #voltar a main
  	
  salvar:
  	j main #voltar a main
  	
  recarregar:
    	j main #voltar a main
    	
  formatar:
    	j main #voltar a main
   
    	
  ############################# cardapio ############################## cardapio  ############################# cardapio ############################## 
  
  compara_cardapio:
  	addi $sp, $sp, -4 # abro espaco pra 1 words na pilha
	sw $ra, 0($sp) #salvo RA
  	la $s0, item_20 #carrega address para t0
  	addi $s1, $0, 20 #vezes que vai decrementar
  loop_cardapio:
  	# XX-XXXXX-X...
  	compara_cmd(12, $s0, 0, 2) # comparando posição 12 da entrada, com a string do item20-19-18... da posicao 0, ate 2 bytes
  	beq $v0, $0, adicionar_item #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, numero_incorreto #numero é maior que 20
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, numero_incorreto #numero é menor que 01
	subi $s0, $s0, 32 #numero menor, vamos indo de 20 a 1 tentando achar ele, subtraindo
	j loop_cardapio
  adicionar_item:
  	compara_cmd(12, $s0, 2, 1) #verifica se ja tem item cadastrado|compara_cmd(%inicio, %address, %inicio2, %num)
  	bne $v0, $0, ja_cadastrado
  	
  	#adiciona o preco
  	la $t0, cmd #carrega address para t0
	addi $a0, $s0, 2 #endereco a partir do preco como destination
	addi $a1, $t0, 15 #source a partir do digito que o option 1 vai aparecer
	li $a2, 5 #num
	jal memcpy
	
	#adiciona a descricao
  	la $t0, cmd #carrega address para t0
	addi $a0, $s0, 7 #endereco a partir do preco como destination
	addi $a1, $t0, 21 #source a partir do digito que o option 1 vai aparecer
	li $a2, 25 #num
	jal memcpy
	
  	imprime_texto(item_adicionado)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  	
  numero_incorreto:
  	imprime_texto(item_invalido)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  	
  ja_cadastrado:
  	imprime_texto(item_ja_cadastrado)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  
  nao_cadastrado:
  	imprime_texto(item_nao_cadastrado)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  
  ############################ mesa_rm ##################### mesa_rm ######################### mesa_rm ################
  mesa_rm_item_rm_item:
  # chamar pilha na proxima função para n perder o $ra dessa função
  	addi $sp, $sp, -4 # abro espaco pra 1 words na pilha
	sw $ra, 0($sp) #salvo RA
  	la $s0, item_20 #carrega address para t0
  	addi $s1, $0, 20 #vezes que vai decrementar
   loop_verifica_item_rm_item:
  	compara_cmd(16, $s0, 0, 2) # compara 2 posições na string gravada em $s0 com a posição 16 do comando
  	beq $v0, $0, verifica_item_cadastrado_rm_item #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, numero_incorreto #numero é maior que 15
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, numero_incorreto #numero é menor que 01
	subiu $s0, $s0, 32 #numero menor, vamos indo de 15 a 1 tentando achar ele, subtraindo
	j loop_verifica_item_rm_item
  verifica_item_cadastrado_rm_item:
    	compara_cmd(16, $s0, 7, 1) #verifica se ja tem item cadastrado - com descrição
  	beq $v0, $0, nao_cadastrado # se a descrição for = nula n cadastrado
  	
  	add $s2, $0, $s0 ####################################### $s2 esta com o endereço do item atual
  	addi $s6, $s1, -1 # agora s1 é o index do item atual para ser decrementado (posicao s1 anterior -1)
  	
   # buscando_mesa:
  	la $s0, mesa_15 #carrega address para t0
  	addi $s1, $0, 15 #vezes que vai decrementar
  	loop_busca_mesa_rm_item:
  # mesa_ad_item-01-01" codigo mesa pos 13, codigo item posição 16 mesa - X(ocupação) - XX(code) - DDDXXXXXXXX -phone - Xs resto nome 
  	compara_cmd(13, $s0, 1, 2) # compara 2 posições na string gravada em $s0 com a posição 13 do comando
  	beq $v0, $0,   busca_mesa_relatorio_rm_item #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, codigo_mesa_incorreto #numero é maior que 15
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, codigo_mesa_incorreto #numero é menor que 01
	subiu $s0, $s0, 64 # numero menor, vamos indo de 15 a 1 tentando achar ele, subtraindo
	j loop_busca_mesa_rm_item
	
    busca_mesa_relatorio_rm_item:
        # ainda verificando a mesa e nao mesa relatorio
        lb $t0, 0($s0) # posição do status se 0 está desocupado
        addi $t1, $0, 1 # nao precisa ser 1 em ascii - 1 esta  ocupado
  	bne $t0, $t1, mesa_nao_ocupada # se status for 1, mesa ainda nao ocupada
  	
  	add $s3, $0, $s0 # $s3 está endereço da mesa
  	add $s4, $s3, 32 # s4 está com o endereço da mesa relatorio da mesa atual
  	add $s1, $s4, $s6 ## agora s1 endereço mesa relatorio + index do item-1
	
  	
  	remover_item_rm_item:
  	
  	# s1 - posicao do item no relatorio,  s2 - endereço item , s3 - endereço mesa, s4 - endereço mesa_relatorio ################################
  	
  	# decrementando num de pedidos do item
  	lb $t1 , 0($s1) # carrega o num em bytes de pedidos ja feitos desse item
  	subi $t0, $t1, 1 # num anterior -=1 num de pedido
  	bltz $t0, item_nao_consta_na_mesa
  	sb $t0, 0($s1) # atualizando num de pedidos do item
  	
  	# convertendo string em int e somando para novo saldo total
  	addiu $a0, $s4, 20 # posição 20 é o endereço do saldo total da mesa_relatorio
  	addi $a1, $0, 6 # num de bytes da prox string
  	addu $s7, $0, $a0 ################################################# guardando posição do saldo para gravar no final
  	
  	jal str_Para_int
  	
  	move $t5, $v0 # valor convertido em t2
  	

        addiu $a0, $s2, 2 # endereço do valor do item em s2 # XX - codigo - XXXXX - preço
        addi $a1, $0, 5 # num de bytes da prox string
        jal str_Para_int
        

        sub $a0, $t5,$v0  # saldo total = preço item

        # convertendo para string novamente # a0 contem o valor novo do saldo total - abaixo params int to string
	# a0 inteiro
	# a1 endereço
	# a2 contador
        add $a1, $0, $s7 # num de bytes da prox string
        add $a2, $0, 6 # index final da string de 6b
        jal intToStr # logo abaixo ira ser salvo valor da nova string no saldo total
        
        add $a0, $0, $s7 # endreço
        add $a1, $0, 6 # bytes percoriddos
        jal fill_zero_string # preenche /0 com 0

  	imprime_texto(item_removido)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
  	
  	
  ############################ mesa_ad_item ##################### mesa_ad_item ######################### mesa_ad_item
  mesa_ad_item_ad_item:  
    	# chamar pilha na proxima função para n perder o $ra dessa função
  	addi $sp, $sp, -4 # abro espaco pra 1 words na pilha
	sw $ra, 0($sp) #salvo RA
  	la $s0, item_20 #carrega address para t0
  	addi $s1, $0, 20 #vezes que vai decrementar
   loop_verifica_item_ad_item:
  	compara_cmd(16, $s0, 0, 2) # compara 2 posições na string gravada em $s0 com a posição 16 do comando
  	beq $v0, $0, verifica_item_cadastrado_ad_item #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, numero_incorreto #numero é maior que 15
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, numero_incorreto #numero é menor que 01
	subiu $s0, $s0, 32 #numero menor, vamos indo de 15 a 1 tentando achar ele, subtraindo
	j loop_verifica_item_ad_item
  verifica_item_cadastrado_ad_item:
    	compara_cmd(16, $s0, 7, 1) #verifica se ja tem item cadastrado - com descrição
  	beq $v0, $0, nao_cadastrado # se a descrição for = nula n cadastrado
  	
  	add $s2, $0, $s0 ####################################### $s2 esta com o endereço do item atual
  	addi $s6, $s1, -1 # agora s1 é o index do item atual para ser decrementado (posicao s1 anterior -1)
  	
   # buscando_mesa:
  	la $s0, mesa_15 #carrega address para t0
  	addi $s1, $0, 15 #vezes que vai decrementar
  	loop_busca_mesa_ad_item:
  # mesa_ad_item-01-01" codigo mesa pos 13, codigo item posição 16 mesa - X(ocupação) - XX(code) - DDDXXXXXXXX -phone - Xs resto nome 
  	compara_cmd(13, $s0, 1, 2) # compara 2 posições na string gravada em $s0 com a posição 13 do comando
  	beq $v0, $0,   busca_mesa_relatorio_ad_item #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, codigo_mesa_incorreto #numero é maior que 15
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, codigo_mesa_incorreto #numero é menor que 01
	subiu $s0, $s0, 64 # numero menor, vamos indo de 15 a 1 tentando achar ele, subtraindo
	j loop_busca_mesa_ad_item
	
    busca_mesa_relatorio_ad_item:
        # ainda verificando a mesa e nao mesa relatorio
        lb $t0, 0($s0) # posição do status se 0 está desocupado
        addi $t1, $0, 1 # nao precisa ser 1 em ascii - 1 esta  ocupado
  	bne $t0, $t1, mesa_nao_ocupada # se status for 1, mesa ainda nao ocupada
  	
  	add $s3, $0, $s0 # $s3 está endereço da mesa
  	add $s4, $s3, 32 # s4 está com o endereço da mesa relatorio da mesa atual
  	add $s1, $s4, $s6 ## agora s1 endereço mesa relatorio + index do item-1
	
	# verofocando se mesa ja possui 20 pedidos
  	addiu $t0, $s4, 0 # endereço da mesa relatorio copiado
  	li $t1, 20 # t1=20 sera o limite de pedidos contado para cada tipo de item da mesa
  	li $t2, 0 # valor total de pedidos feitos na mesa
  	li $t4, 20 # numero de posicoes percorridas
  	
  	loop_conta_pedidos_da_mesa_ad_item:

 	beq $t1,$t2, limite_de_pedidos_alcancado  # t1 for <= 0 limite de itens na mesa alcançado
 	blez, $t4, registrar_pedido_ad_item  # t3 for <= 0 limite de espaço de itens na mesa alcançado - registrar item
 	lb $t3, ($t0) # carrega o byte em t0
 	add $t2, $t2, $t3 # valor total antigo + atual
 	addi $t0, $t0 , 1 # fara isso 20 vezes ate posição 19 em mesa relatorio
 	subi $t4, $t4, 1 # 20 -1 19-1, ... ate 0 - contou todos os espaços possiveis de memoria

	j loop_conta_pedidos_da_mesa_ad_item
  	
  	registrar_pedido_ad_item:
  	
  	# s1 - posicao do item no relatorio,  s2 - endereço item , s3 - endereço mesa, s4 - endereço mesa_relatorio ################################
  	
  	# incrementando num de pedidos do item
  	lb $t1 , 0($s1) # carrega o num em bytes de pedidos ja feitos desse item
  	addi $t0, $t1, 1 # num anterior +=1 num de pedido
  	sb $t0, 0($s1) # atualizando num de pedidos do item
  	
  	# convertendo string em int e somando para novo saldo total
  	addiu $a0, $s4, 20 # posição 20 é o endereço do saldo total da mesa_relatorio  	
  	addi $a1, $0, 6 # num de bytes da prox string
  	addu $s7, $0, $a0 ################################################# guardando posição do saldo para gravar no final
  	
  	add $a0, $0, $s7 # endereço 
        add $a2, $0, 6 # bytes percoriddos
  	jal str_Para_int # converte string para int
  	
  	move $t5, $v0 # valor convertido em t2
  	
        addiu $a0, $s2, 2 # endereço do valor do item em s2 # XX - codigo - XXXXX - preço
        addi $a1, $0, 5 # num de bytes da prox string
        jal str_Para_int

        add $a0, $v0, $t5 # valor atual ATE AQUI ESTÁ CORRETO SEGUNDO O DEBUG o valor é 11399 em a0

        # convertendo para string novamente # a0 contem o valor novo do saldo total
	# a0 inteiro
	# a1 endereço
	# a2 contador
        add $a1, $0, $s7 # num de bytes da prox string
        add $a2, $0, 6 # index final da string de 6b
		
        jal intToStr # logo abaixo ira ser salvo valor da nova string no saldo total
        #v0 está com a o endereço da nova string 
        
        add $a0, $0, $s7 # num de bytes preencher '0'
        add $a1, $0, 6 # bytes percoriddos
        jal fill_zero_string

  	imprime_texto(pedido_adicionado)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
	
  	
  ############################ mesa_iniciar ##################### mesa_iniciar ######################### mesa_iniciar
  verifica_mesa:
  	addi $sp, $sp, -4 # abro espaco pra 1 words na pilha
	sw $ra, 0($sp) #salvo RA
  	la $s0, mesa_15 #carrega address para t0
  	addi $s1, $0, 15 #vezes que vai decrementar
  loop_mesa:
  # posição 13 em mesa_iniciar-12-81983678188-jose da silva é o caractere "1"
  	compara_cmd(13, $s0, 1, 2) # compara 2 posições na string gravada em $s0 com a posição 13 do comando
  	beq $v0, $0, iniciar_mesa #verifica se as strings sao iguais e desvia se for
	addi $t0, $0, 1 #coloca o valor 1 em t0
	beq $v0, $t0, codigo_mesa_incorreto #numero é maior que 15
	subi $s1, $s1, 1 #s1--
	beq $s1, $0, codigo_mesa_incorreto #numero é menor que 01
	subi $s0, $s0, 64 #numero menor, vamos indo de 15 a 1 tentando achar ele, subtraindo
	j loop_mesa
  iniciar_mesa:
        lb $t0, 0($s0) # posição do status se 0 está desocupado
        addi $t1, $0, 1 # valor 1 no byte  nao precisa ser ascii
  	beq $t0, $t1, mesa_ja_ocupada # se status for 1, mesa ocupada
  	
  	# muda status
	sb $t1, ($s0) # coloca 1 no status a posição 0 da string s0
  	
  	#adiciona o telefone
  	la $t0, cmd #carrega address para t0
	addi $a0, $s0, 3 #endereco a partir do telefone como destination
	addi $a1, $t0, 16 #source a partir do digito que o option 2 vai aparecer
	li $a2, 11 # num
	jal memcpy
	
	#adiciona a nome responsavel
  	la $t0, cmd #carrega address para t0
	addi $a0, $s0, 14 # endereco + 16 posições a partir de codigo mesa, responsavel como destination
	addi $a1, $t0, 28 #source a partir do digito que o option 3 vai aparecer
	li $a2, 18 # num de bytes reservado para o nome do responsavel
	jal memcpy
	
	break_line
  	imprime_texto(mesa_iniciada)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  	
  codigo_mesa_incorreto:
  	imprime_texto(mesa_inexistente)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  	
  mesa_ja_ocupada:
  	imprime_texto(mesa_ocupada)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
  	
    mesa_nao_ocupada:
  	imprime_texto(mesa_desocupada)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
limite_de_pedidos_alcancado:
	 imprime_texto(mesa_limitada)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
 
   item_nao_consta_na_mesa:
	imprime_texto(item_nao_consta)
  	break_line
  	lw $ra, 0($sp) #recupero o RA original
	addi $sp, $sp, 4 # coloco minha pilha na posicao inicial.
  	jr $ra
